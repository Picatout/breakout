//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8BB1_Register_Enums.h>

#include "chip8.h"

//-----------------------------------------------------------------------------
// TIMER0_ISR
//-----------------------------------------------------------------------------
//
// TIMER0 ISR Content goes here. Remember to clear flag bits:
// TCON::TF0 (Timer 0 Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
{
	TCON_TF0=0;
	P0_B7^=1;
	TL0=tmr_reload&255;
	TH0=tmr_reload>>8;
}

/* The PCA0 is used to generate NTSC signal
 *  channel 0 count video lines and start sync pulse
 *  channel 1 end sync pulse
 *  channel 3 serialize video pixels using SPI0
 */

//-----------------------------------------------------------------------------
// PCA0_ISR
//-----------------------------------------------------------------------------
//
// PCA0 ISR Content goes here. Remember to clear flag bits:
// PCA0CN0::CCF0 (PCA Module 0 Capture/Compare Flag)
// PCA0CN0::CCF1 (PCA Module 1 Capture/Compare Flag)
// PCA0CN0::CCF2 (PCA Module 2 Capture/Compare Flag)
// PCA0CN0::CF (PCA Counter/Timer Overflow Flag)
// PCA0PWM::COVF (Cycle Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT_USING (PCA0_ISR, PCA0_IRQn,1)// use register bank 1
{
	char i;
	unsigned char xdata *ln;

	static int line_count=0;
	static unsigned char f_even=0;
	static unsigned char f_video=0;

	if (PCA0CN0_CCF0) { // hline sync
		PCA0CN0_CCF0=0;
		line_count++;
		if ((f_even && (line_count==262))||(!f_even && (line_count==263))) {
			line_count=0;
			f_even^=1;
		}
		P0_B4=0;
		PCA0CP0+=400;
	} else if (PCA0CN0_CCF1) { // hsync pulse end
		PCA0CN0_CCF1=0;
		PCA0CP1+=400;
		switch(line_count) {
			case 1:
			case 2:
			case 3:
			break;
			case 40:
			f_video=1;
			P0_B4=1;
			break;
			case 232:
			f_video=0;
			default:
			P0_B4=1;
		} //switch

	} else if (PCA0CN0_CCF2) { // video output
		PCA0CN0_CCF2=0;
		PCA0CP2+=400;
		if (f_video) {
			ln=&video[(line_count-40)/6*8];
			for (i=0;i<8;i++) {
				SPI0DAT= *ln++;
				while (!(SPI0CN0&SPI0CN0_TXBMT__BMASK));
			}
			SPI0DAT=0;
		}
	}
}

